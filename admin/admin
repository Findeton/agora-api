#!/usr/bin/env python

import requests
import json
import time

import BaseHTTPServer
from SimpleHTTPServer import SimpleHTTPRequestHandler
from BaseHTTPServer import BaseHTTPRequestHandler, HTTPServer
from SocketServer import ThreadingMixIn
import SocketServer
import threading

import subprocess

import argparse
import sys
import __main__
from argparse import RawTextHelpFormatter

from datetime import datetime
import hashlib
import codecs
import traceback

import os.path
import os

PK_TIMEOUT = 60*10 # with three authorities 60 secons was not enough
TALLY_TIMEOUT = 3600*6 # 6 hours should be enough for what we do :-P
CERT = '/srv/certs/selfsigned/cert.pem'
KEY = '/srv/certs/selfsigned/key-nopass.pem'

# configuration
localPort = 8000
node = '/usr/local/bin/node'

def getLocalHostname():
    me = subprocess.check_output(["./eopeers", "--show-mine"])
    pkg = json.loads(me)

    return pkg['hostname']

def getBackendConfig():
    path = os.path.join('..', 'config.json')
    with open(path, 'r') as f:
        config = json.loads(f.read())

    return config

def getElectionConfig(dir, eopeers_dir):
    if not os.path.isdir(dir):
        print("%s is not a directory" % dir)
        exit(1)

    path = os.path.join(dir, "config.json")
    if not os.path.isfile(path):
        print("%s is not a file" % path)
        exit(1)
    print("loading config in %s" % path)
    with open(path, 'r') as f:
        config = json.loads(f.read())

    if not 'director' in config:
        print("director not found in config")
        exit(1)
    if not 'authorities' in config:
        print("authorities not found in config")
        exit(1)

    config['path'] = dir

    config["authorities"] = config['authorities'].replace(' ','').split(',')

    # if id not present, use directory name
    if not 'election-id' in config:
        config['election-id'] = os.path.basename(os.path.normpath(dir))

    # authorities and director
    auths_data = getAuthData(eopeers_dir)

    authorities = []
    for auth in auths_data:
        if auth['hostname'] == config['director']:
            authorities.insert(0, auth)
        elif auth['hostname'] in config['authorities']:

            authorities.append(auth)

    # check that all requested authorities were found
    required = list(config['authorities'])
    required.append(config['director'])
    required = set(required)

    found = [a['hostname'] for a in authorities]
    if len(found) != len(required):
        not_found = str(required - set(found))
        print("some peers were not found: %s" % not_found)
        exit(1)

    config['auths'] = authorities

    # local host, port
    localHostname = getLocalHostname()
    config['local-hostname'] = localHostname
    config['local-port'] = localPort

    return config

def getTallyData(config):
    return {
        # 'election_id': electionId,
        "callback_url": "http://" + config['local-hostname'] + ":" + str(config['local-port']) + "/receive_tally",
        "extra": [],
        "votes_url": "http://" + config['local-hostname'] + ":" + str(config['local-port']) + "/",
        "votes_hash": "sha512://"
    }


def _apiUrl(path, auth):
    '''
    Given a full api (without the initial '/') path and a package dict, returns
    a well formed url
    '''
    return "https://%(hostname)s:%(port)d/%(path)s" % dict(
        hostname=auth["hostname"],
        port=auth.get("port", 5000),
        path=path
    )

def getAuthDataForPost(config):
    i = 1
    ret_data = []
    print("\nusing the following authorities:")
    for auth in config['auths']:
        ret_data.append({
            "name": "Auth%d" %i,
            "orchestra_url": _apiUrl("api/queues", auth),
            "ssl_cert": auth["ssl_certificate"]
        })
        if i == 1:
            print(" 1. %s (this is the orchestra "
                  "director)" % auth['hostname'])
        else:
            print(" %d. %s" % (i, auth['hostname']))

        i += 1

    return ret_data

def getAuthData(eopeers_dir):
    if not os.path.isdir(eopeers_dir):
        print("%s is not a directory" % eopeers_dir)
        exit(1)

    l = os.listdir(eopeers_dir)
    if len(l) == 0:
        print("%s is an empty directory" % eopeers_dir)
        exit(1)

    auths_data = []
    for fname in os.listdir(eopeers_dir):
        path = os.path.join(eopeers_dir, fname)
        with open(path, 'r') as f:
            auths_data.append(json.loads(f.read()))

    return auths_data

def getStartData(config):
    return {
        "election_id": config['election-id'],
        "callback_url": "http://" + config['local-hostname'] + ":" + str(config['local-port']) + "/key_done",
        "is_recurring": config['is_recurring'],
        "extra": config['extra'],
        "title": config['title'],
        "url": config['url'],
        "description": config['description'],
        "questions_data": config['questions_data'],
        "voting_start_date": config['voting_start_date'],
        "voting_end_date": config['voting_end_date'],
        "authorities": getAuthDataForPost(config)
    }
    '''return {
        # "election_id": electionId,
        "callback_url": "http://" + config['local-hostname'] + ":" + str(config['local-port']) + "/key_done",
        "is_recurring": False,
        "extra": [],
        "title": "Test election",
        "url": "https://example.com/election/url",
        "description": "election description",
        "questions_data": [{
            "question": "Who Should be President?",
            "tally_type": "ONE_CHOICE",
            # "answers": ["Alice", "Bob"],
            "answers": [
                {'a': 'ballot/answer',
                'details': '',
                'value': 'Alice'},
                {'a': 'ballot/answer',
                'details': '',
                'value': 'Bob'}
            ],
            "max": 1, "min": 0
        }],
        "voting_start_date": "2013-12-06T18:17:14.457000",
        "voting_end_date": "2013-12-09T18:17:14.457000",
        "authorities": getAuthDataForPost(config)
    }'''

# code

# thread signalling
cv = threading.Condition()

class ThreadingHTTPServer(SocketServer.ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass

class RequestHandler(SimpleHTTPRequestHandler):
    def do_GET(self):
        print("> HTTP received " + self.path)
        if(self.path == "/exit"):
            self.send_response(204)
            cv.acquire()
            cv.done = True
            cv.notify()
            cv.release()
        else:
            SimpleHTTPRequestHandler.do_GET(self)

    def do_POST(self):
        length = int(self.headers['Content-Length'])
        print("> HTTP received " + self.path + " (" + str(length) + ")")
        raw = self.rfile.read(length).decode('utf-8')
        print(raw)
        data = json.loads(raw)

        # print(data)
        self.send_response(200)
        cv.acquire()
        cv.done = True
        cv.data = data
        cv.notify()
        cv.release()

# misc\utils.py
BUF_SIZE = 10*1024
def hash_file(filePath):
    '''
    Returns the hexdigest of the hash of the contents of a file, given the file
    path.
    '''
    hash = hashlib.sha512()
    f = open(filePath, 'r')
    for chunk in f.read(BUF_SIZE):
        hash.update(chunk)
    f.close()
    return hash.hexdigest()

def writeVotes(votesData, filePath):
    # forms/election.py:save
    votes = []
    for vote in votesData:
        data = {
            "a": "encrypted-vote-v1",
            "proofs": [],
            "choices": [],
            "voter_username": 'foo',
            "issue_date": str(datetime.now()),
            "election_hash": {"a": "hash/sha256/value", "value": "foobar"},
        }

        q_answer = vote['question0']
        data["proofs"].append(dict(
            commitment=q_answer['commitment'],
            response=q_answer['response'],
            challenge=q_answer['challenge']
        ))
        data["choices"].append(dict(
            alpha=q_answer['alpha'],
            beta=q_answer['beta']
        ))

        votes.append(data)

    # tasks/election.py:launch_encrypted_tally
    with codecs.open(filePath, encoding='utf-8', mode='w+') as votes_file:
        for vote in votes:
            # votes_file.write(json.dumps(vote['data'], sort_keys=True) + "\n")
            votes_file.write(json.dumps(vote, sort_keys=True) + "\n")

    # hash = hash_file(fileName)

    # return hash

def startServer(port):
    print("> Starting server on port %s" % str(port))
    server = ThreadingHTTPServer(('localhost', port),RequestHandler)
    thread = threading.Thread(target = server.serve_forever)
    thread.daemon = True
    thread.start()

def startElection(config, url, data):
    # data['election_id'] = electionId
    print("> Creating election " + config['election-id'])
    print(json.dumps(data))
    cv.done = False
    r = requests.post(url, data=json.dumps(data), verify=False, cert=(CERT, KEY))
    print("> " + str(r))

def waitForPublicKey():
    start = time.time()
    cv.acquire()
    cv.wait(PK_TIMEOUT)
    pk = ''
    if(cv.done):
        diff = time.time() - start
        try:
            pk = cv.data['session_data'][0]['pubkey']
            print("> Election created (" + str(diff) + " sec), public key is")
            print(pk)
        except:
            print("* Could not retrieve public key " + str(cv.data))
            print traceback.print_exc()
    else:
        print("* Timeout waiting for public key")
    cv.release()

    return pk

def doTally(config, url, data, votesFile, hash):
    data['votes_url'] = data['votes_url'] + config['path'] + "/" + votesFile
    data['votes_hash'] = data['votes_hash'] + hash
    data['election_id'] = config['election-id']
    # print("> Tally post with " + json.dumps(data))
    print("> Requesting tally..")
    cv.done = False
    r = requests.post(url, data=json.dumps(data), verify=False, cert=(CERT, KEY))
    print("> " + str(r))

def waitForTally():
    start = time.time()
    cv.acquire()
    cv.wait(TALLY_TIMEOUT)
    ret = ''
    if(cv.done):
        diff = time.time() - start
        # print("> Received tally data (" + str(diff) + " sec) " + str(cv.data))
        print("> Received tally data (" + str(diff) + " sec)")
        if('tally_url' in cv.data['data']):
            ret = cv.data['data']
    else:
        print("* Timeout waiting for tally")
    cv.release()

    return ret

def downloadTally(config, url):
    fileName = config['election-id'] + '.tar.gz'
    path = os.path.join(config['path'], fileName)
    print("> Downloading to %s" % path)
    with open(path, 'wb') as handle:
        request = requests.get(url, stream=True, verify=False, cert=(CERT, KEY))

        for block in request.iter_content(1024):
            if not block:
                break

            handle.write(block)






''' driving functions '''

def create(config):
    electionId = config['election-id']
    startServer(config['local-port'])
    startData = getStartData(config)
    startUrl = _apiUrl("public_api/election", config['auths'][0])
    print("> requesting election at %s" % startUrl)
    startElection(config, startUrl, startData)
    publicKey = waitForPublicKey()
    pkFile = 'pk_' + electionId

    if(len(publicKey) > 0):
        print("> Saving pk to " + pkFile)
        with codecs.open(os.path.join(config['path'], pkFile), encoding='utf-8', mode='w+') as votes_file:
            votes_file.write(json.dumps(publicKey))
    else:
        print("No public key, exiting..")
        exit(1)

    return pkFile

def encrypt(config):
    electionId = config['election-id']
    pkFile = 'pk_' + electionId
    votesFile = config['vfile']
    votesCount = config['vcount']
    ctexts = 'ctexts_' + electionId

    print("> Encrypting votes (" + votesFile + ", pk = " + pkFile + ", " + str(votesCount) + ")..")
    pkPath = os.path.join(config['path'], pkFile)
    votesPath = os.path.join(config['path'], votesFile)
    ctextsPath = os.path.join(config['path'], ctexts)

    if(os.path.isfile(pkPath)) and (os.path.isfile(votesPath)):
        output, error = subprocess.Popen([node, "js/encrypt.js", pkPath, votesPath, str(votesCount)], stdout = subprocess.PIPE).communicate()

        print("> Received Nodejs output (" + str(len(output)) + " chars)")
        parsed = json.loads(output)

        print("> Writing file to " + ctextsPath)
        writeVotes(parsed, ctextsPath)
    else:
        print("No public key or votes file, exiting..")
        exit(1)

def tally(config, start_server = True):
    if(start_server):
        startServer(config['local-port'])

    electionId = config['election-id']

    ctexts = 'ctexts_' + electionId
    ctextsPath = os.path.join(config['path'], ctexts)

    # need hash
    hash = hash_file(ctextsPath)
    print("> Votes hash is " + hash)
    tallyData = getTallyData(config)
    tallyUrl = _apiUrl('public_api/tally', config['auths'][0])
    doTally(config, tallyUrl, tallyData, ctexts, hash)
    tallyResponse = waitForTally()
    print(tallyResponse)

    if('tally_url' in tallyResponse):
        print("> Downloading tally from " + tallyResponse['tally_url'])
        downloadTally(config, tallyResponse['tally_url'])
    else:
        print("* Tally not found in http data")

def full(config):
    electionId = config['election-id']

    pkFile = create(config)

    if(os.path.isfile(os.path.join(config['path'], pkFile))):
        encrypt(config)
        tally(config, False)
    else:
        print("No public key, exiting..")

def main(argv):

    parser = argparse.ArgumentParser(description='EO testing script', formatter_class=RawTextHelpFormatter)
    parser.add_argument('command', nargs='+', default='full', help='''create <election_dir>: creates an election
encrypt <election_dir>: encrypts votes
tally <election_dir>: launches tally
full <election_dir>: does the whole process''')
    parser.add_argument('--eopeers-dir', help='directory with the eopeers packages to use as authorities', default = '/etc/eopeers/')
    parser.add_argument('--vfile', help='json file to read votes from when encrypting', default = 'votes.json')
    parser.add_argument('--vcount', help='number of votes to generate (generates duplicates if more than in json file)', type=int, default = 0)
    args = parser.parse_args()
    command = args.command[0]
    if hasattr(__main__, command):
        if(len(args.command) == 2):
            config = getElectionConfig(args.command[1], args.eopeers_dir)
            backendConfig = getBackendConfig()
            print(backendConfig)
            exit(1)
            config['vfile'] = args.vfile
            config['vcount'] = args.vcount

            eval(command + "(config)")
        else:
            parser.print_help()
        '''if(command == 'create') or (command == 'full'):
            args.electionId = str(time.time()).replace(".", "")
        elif(len(args.command) == 2):
            args.electionId = args.command[1]

        eval(command + "(args)")'''
    else:
        parser.print_help()

if __name__ == "__main__":
    main(sys.argv[1:])